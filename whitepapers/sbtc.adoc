= sBTC: Design of a Trustless Two-way Peg for Bitcoin
:toc:
:sectnums:

[.normal]
Unlocking Bitcoin to be a fully programmable, productive asset would allow Bitcoin to be the backbone of DeFi and a more secure web3. The ability to move Bitcoin in and out of a smart contract-enabled L2 freely and for these contracts to write to the Bitcoin blockchain in a decentralized, trust-minimized way can unlock hundreds of billions of dollars of passive BTC for web3 and a broader decentralized economy. In this paper, we present a novel decentralized Bitcoin peg mechanism. Using this peg, a BTC-pegged asset can be issued on Bitcoin layers that is 1:1 pegged to BTC and does not rely on centralized or pre-determined actors for its functionality. Instead, the peg mechanism operates in a decentralized manner using an open-membership group of dynamic actors that are economically incentivized and can start or stop contributing to the peg functionality.

A decentralized two-way Bitcoin peg has been an unsolved, "holy grail" problem in the Bitcoin ecosystem, especially as it can enable decentralized, trust-minimized writes to Bitcoin. A decentralized peg allows BTC to become a productive asset without entrusting it to centralized entities and to be deployed in applications like decentralized BTC-based lending, BTC-backed stablecoins, etc. A wrapped Bitcoin asset (wBTC) on Ethereum has ranged from $5-$15 billion in usage, even though it is entrusted to a single custodian and hence antithetical to Bitcoin ethos. We describe the design of a Bitcoin-pegged asset, called sBTC, that implements the decentralized peg mechanism using the unique interactions of the Stacks Bitcoin L2 and Bitcoin main chain (L1) to provide high performance and decentralized security.

Bitcoin is the most decentralized, secure, and durable blockchain. BTC is a unique and valuable asset in the industry, and the Bitcoin blockchain is the best final settlement layer for transactions. Bitcoin optimizes for simplicity and decentralization at the base layer <<bitcoin>>; Bitcoin is, by design, relatively slow and does not natively provide the fully-expressive smart contracts needed to build sophisticated applications. This is unlikely to, and should not, change. Faster and more sophisticated applications must therefore be built outside of the base layer. Bitcoin layers enable this, interacting with the Bitcoin L1 as necessary but providing high performance and advanced functionality outside the base layer. (We use “Bitcoin layer” as a broad term meaning a functionality layer outside of L1, our definition of Bitcoin layer includes concepts like L2s, sidechains<<sidechains>>, etc.) Fast payments (Lightning), asset issuance (Liquid), and general smart contracts (Stacks and RSK) are examples of functionality provided by Bitcoin layers. We consider Stacks a Bitcoin L2, and lay out the various properties that comprise a Bitcoin L2 in more detail in the Stacks whitepaper, outlining the Nakamoto release.

An ideal Bitcoin L2 needs to have seven properties:

1. Open-source and decentralized development process
2. Full VM support and ability to program with expressive, high-level languages
3. Fast transaction and block times (don’t need to wait 10-30 minutes for Bitcoin blocks)
4. A trust-minimized way to move BTC between L1 and L2
5. BTC as the primary asset deployed in L2 apps
6. The ability to pay for L2 transactions in BTC
7. The ability to unilaterally withdraw your BTC back from the L2 with no counterparty risk

While there has been noticeable progress on Bitcoin layers, the various Bitcoin layers as of 2023 have some limitations. Stacks V1 had properties 1 and 2, but was missing the rest. Nakamoto brings properties 3, 4, and 5, with discussions and work currently underway to accomplish 6.

Currently, Lightning is the only L2 that has property 7, and the only way to truly take advantage of this is to run your own Lightning node, a complex undertaking few users engage in. Furthermore, Lightning is missing property 2, which means we cannot unlock any additional functionality beyond what that Bitcoin L1 is already capable of.

The Stacks whitepaper goes into more detail on the various L2 properties and how Stacks approaches them. In contrast, recent Ethereum layers have all seven properties for ETH (although points 4 and 7 could be debated depending on the mechanism and centralization of the L2) and have recently experienced significant growth in users and capital deployed. For Ethereum, the various layers are used primarily for scalability, but for Bitcoin the layers are more important given the limited L1 functionality; Bitcoin layers are required for both scalability and new functionality.

This work on sBTC, in conjunction with the Nakamoto release on the Stacks chain itself, brings us significantly closer to building ideal Bitcoin layers. Not only can users have access to fully-expressive smart contracts on a decentralized Bitcoin L2, but they can easily move BTC in and out of the layer in a decentralized manner. Meanwhile, the L2 transactions can be secured by 100% of the Bitcoin L1 security. The decentralized peg mechanism unlocks a new era of Bitcoin applications that can accelerate the growth of the Bitcoin economy.

Our sBTC peg design has the following properties that make it unique:

* *Open and decentralized:* The peg is operated by an open-membership set of dynamically changing signers instead of a predetermined set of federated or centralized parties; the decentralized signers are economically incentivized.
* *Censorship resistant:* The peg operations like signer selection, peg-out requests, etc., happen on the Bitcoin L1 and follow Bitcoin's censorship-resistance, meaning that external actors in the Stacks layer cannot censor these operations.
* *Cheap peg in/out:* The threshold signers are incentivized through BTC rewards from the Stacks layer consensus, giving them strong economic incentives to participate without introducing any additional peg fees.
* *On-chain Bitcoin oracle:* There is no dependency on an external Oracle for peg operations as it uses a unique price oracle implemented on-chain on the Bitcoin L1.
* *Bitcoin security:* The Stacks layer and the peg state automatically forks with Bitcoin L1, automatically settles all transactions on Bitcoin L1 with 100% Bitcoin finality, giving strong security guarantees.
* *Commercially viable:* Real-world participation data suggests that sBTC can reach a circulating supply of hundreds of millions to billions of dollars given recent capital locked in Stacks consensus, making sBTC commercially viable and scalable.

Other than allowing easy movement of BTC in and out of layers, the peg mechanism also allows smart contracts on the layers to write to Bitcoin in a trustless way. This *Bitcoin write functionality* is a major unlock for developers enabling them to build smart contracts that can programmatically send BTC to Bitcoin addresses through the decentralized peg.

sBTC is being developer and rolled out in several phases. Much of this whitepaper describes the current final design of sBTC. In the Progressive Enhancement of sBTC section towards the end of the document, we will outline the various phases in which sBTC will be released, and how each phase differs.

== Decentralized Two-way Bitcoin Peg
Smart contracts should not operate at the Bitcoin base layer for security and performance reasons; the base layer should remain simple. We present a decentralized, open-membership Bitcoin peg mechanism using the Stacks Bitcoin layer: BTC can be locked on the Bitcoin L1, and an equal amount of a derived asset, called sBTC, whose value is pegged 1:1 to BTC, is issued on the Stacks layer. Smart contracts can execute using sBTC and, when desired, sBTC can be withdrawn back out to BTC (i.e. sBTC is destroyed, and an equal amount of BTC is released on the Bitcoin chain automatically). Smart contracts can programmatically send sBTC (withdraw it out as BTC) to a BTC address, solving the Bitcoin write problem where contracts outside the Bitcoin L1 can write to the Bitcoin blockchain in a decentralized way, without relying on a centralized intermediary or set of intermediaries.

Readers should see the latest version of the Stacks paper<<stacks-nakamoto>> for details on the proposed Nakamoto release and the latest security model of using Bitcoin finality.

The sBTC approach allows smart contracts to use Bitcoin as the monetary asset but with faster and cheaper transactions at the Stacks layer. BTC-derived pegged assets have been implemented earlier, including wBTC on Ethereum, tBTC on Threshold, RBTC on RSK, and L-BTC on Liquid.

We discuss these more and how they compare to sBTC in the “Related Work” section towards the end of the paper.

sBTC is a decentralized pegged BTC asset operated by a fully permissionless, decentralized, dynamic set of participants with a clear economic incentive to operate the peg properly. Furthermore, because of Stacks' close connection with Bitcoin, sBTC users can use a decentralized peg that is built on top of Bitcoin, rather than needing to move it to the Ethereum ecosystem, as is the case with tBTC.

Such a decentralized Bitcoin peg has been the main roadblock in making BTC a productive asset (to generate profits) by deploying BTC in contracts without entrusting it to centralized entities or needing to move it out of the Bitcoin ecosystem. This can unlock hundreds of billions of dollars of BTC to be deployed in contracts, enabling applications like decentralized BTC lending, BTC-backed stablecoins, etc., with the decentralized security that Bitcoin holders critically desire.

The sBTC peg is enabled by unique characteristics of the Stacks layer and its connection to Bitcoin. In particular:

* The Stacks layer has a unique consensus protocol, Proof of Transfer (PoX), that leverages Bitcoin's Proof of Work (PoW) protocol and naturally supports sBTC. In PoX, Stackers  lock up their capital, participate in the mining process to increase decentralization and security, and perform the task of threshold signing for withdrawal transactions, and in return, are rewarded in BTC. Stacks miners spend BTC to mine Stacks blocks. It is this BTC that is distributed to Stackers as rewards. This allows an incentive-compatible economic guarantee for a successful peg: for Stackers, faithfully maintaining the peg is always their most profitable course of action, and with the Nakamoto release, Stacks miners must build atop the canonical chain tip, Stacks no longer forks on its own. There are interesting nuances and dynamics that arise in order to facilitate economic incentives/security without limiting the growth of sBTC liquidity. These will be discussed in detail in the design details section of this paper.
* Stackers are already rewarded by the core consensus protocol. Therefore, there is no need for users to pay “wrapping fees” when pegging their BTC in and out during normal operation; the protocol rewards provide the economic incentives. This is a significant advantage, as the wrapping fees in custodial systems become high (as in the case of wBTC).
* There is no fork risk with Stacks. The Stacks layer automatically “forks with” the Bitcoin L1, i.e., when Bitcoin L1 forks, the Stacks layer forks accordingly as well. This means that even if Bitcoin forks or reorganizes, the effect on peg operations, peg wallets, and changes to Stacker sets is reflected on the Stacks chain. If Bitcoin forks, then both the Stacker set and their wallet forks with it, and the two resulting Stacker sets and wallets each own BTC on their respective forks. Stackers, therefore, do not lose money due to forks, and forks do not pose a risk to the safety of users' BTC. This is not the case for pegged BTC assets on chains like Ethereum<<ethereum>> that do not fork with Bitcoin: there, a Bitcoin reorg could make the state of the wrapped BTC inconsistent with the canonical Bitcoin fork, requiring intervention.
* The set of threshold signers, called Stackers, are incentivized by BTC rewards from consensus to maintain the liveness of the system and sign withdrawal requests; the BTC rewards are compensation for their work. This compensation in BTC through participation in Stacks consensus is a unique property of the Stacks layer.
* The set of threshold signers is elected through Bitcoin transactions, as contracts on Stacks can read and process Bitcoin transactions. This means that Stacks miners cannot censor the election of Stackers. Similarly, BTC withdrawal requests are also broadcasted as Bitcoin transactions, and Stacks miners cannot ignore these requests.
* The system uses the BTC payouts to stackers as a liveness recovery mechanism as well,  whereby some BTC payouts are repurposed to fulfill withdrawal requests should the Stackers fail to sign withdrawal requests in a timely manner.

The sBTC design is commercially viable because it can scale to a sBTC circulating supply of hundreds of millions of dollars worth of BTC today and potentially to tens of billions of dollars worth of sBTC circulating supply in the future. The upper limit on sBTC supply is determined by a hybrid model (described in detail below) and is tied to the economic size of STX capital locked. As the economy of Bitcoin applications built through the Stacks layer grows and more BTC is made productive through contracts on the Stacks layer, this sBTC circulating supply limit should increase over time.

The sBTC design does not introduce any custodians or trusted centralized/federated parties in the middle. For billions of dollars worth of BTC to be used in smart contracts through a peg-in system, it's critical that no centralized/federated trust is present in the system. Other existing peg systems for Bitcoin, like Liquid or RSK, rely on trusting a federation where the federation members do not put up any collateral as guarantee for their honest behavior. The sBTC system differs from federated peg systems because it is (a) open membership, anyone can join the system easily and become a signer for withdrawal transactions, and (b) the withdrawal signers need to lock more collateral than the value of BTC pegged-in providing strong economic incentives for the signers to maintain liveness of the system (their collateral is not released until the signers process all pending peg-out requests).

The only way to mint new sBTC is by depositing equivalent BTC in a script on the Bitcoin main chain. The system always maintains a 1:1 BTC to sBTC ratio and anyone can monitor the open system to verify that the 1:1 ratio is maintained at all times. This is different from custodian approaches, like wBTC, where proof of BTC reserves is less transparent. Further, in sBTC the Bitcoin script/wallet on the Bitcoin main chain is managed by a decentralized and open-membership group of participants vs any single entity or fixed federation. The threshold signers are economically incentivized to maintain the liveness of the peg i.e., to continue signing withdrawal transactions.

The sBTC design does not include any deposit/withdrawal fees that enables users to deposit to and withdraw from the system as frequently as they wish. The users only need to pay the respective Bitcoin L1 transaction fees when using the peg system. In other wrapped Bitcoin designs like wBTC on  Ethereum there are typically fees associated with the wrapping/unwrapping function. These fees are necessary for the business viability of the custodian that is performing the wrapping function and maintaining the system. The sBTC design uses BTC rewards from Stacks consensus as incentives for the signers and there is no need for an additional peg fee incentive in the design. The signers are offered incentives at a high rate while the deposit/withdraw functionality remains free to users; they only pay gas fees regardless of the amount of BTC.

== Design details of sBTC
The lack of a stateful smart contract system on Bitcoin necessitates the construction of systems in which a representation of locked Bitcoin is traded within a separate smart-contract-powered blockchain. These systems aim to provide a 2-way peg between the representation of the locked BTC ("wrapped BTC") and the BTC itself. At a high level, these systems seek to provide two primitive operations.

* "Deposit": a BTC holder rids themselves of their BTC, and in doing so, receives the equivalent amount of wrapped BTC (sBTC) on Stacks.
* "Withdraw": a sBTC holder destroys their sBTC on the Stacks chain, and receives an equivalent amount of BTC on the Bitcoin chain.

While deposit/withdrawal operations are trivial to implement if a trusted intermediary (a "custodian") can be found to exchange the wrapped BTC for the BTC and vice versa, a robust, incentive-compatible system remains elusive. We identify two key shortcomings in the state-of-the-art 2-way peg systems that we believe renders them insufficiently robust for widespread usage:

* Peg safety failures are irrecoverable. All existing 2-way peg systems that we are aware of do not have a way to recover missing BTC should the peg state ever become corrupted (i.e. through the loss of BTC). Any such recovery, if it happens at all, happens out-of-band through the actions of a trusted intermediary or intermediaries. This places an enormous barrier to entry for users, who would need to vet intermediaries before trusting them with large sums of BTC.
* Reliance on under-incentivized intermediaries. State-of-the-art 2-way peg systems rely on one or more intermediaries to maintain the wallet state, but do not reward them proportional to the value they create. Specifically, these intermediaries provide value even when the transaction volume is low, because user confidence in the system depends on the belief that the intermediaries are nevertheless always available and trustworthy. For example, the reason blockchains have a large coinbase relative to their transaction fees is to incentivize miners to always be available to process transactions. But today, there is no 2-way peg system we are aware of that rewards intermediaries in this manner -- there is no "2-way peg coinbase." Collateralized 2-way pegs suffer a similar shortcoming -- there is little upside to honest participation, but tremendous downside to going offline, which creates a high barrier-to-entry for participating as an intermediary.

sBTC addresses these two short-comings by leveraging unique properties of the Stacks blockchain. Our key insight is that Stacks' PoX consensus algorithm offers a way to recover from 2-way peg safety failures while also properly rewarding intermediaries for the value they provide. Specifically:
* We use the fact that the Stacks blockchain "forks with" the Bitcoin blockchain to propose an open-membership sBTC wallet maintained by Stackers. If Bitcoin forks, then both the Stacker set and their wallet forks with it, and the two resulting Stacker sets and wallets each own BTC on their respective forks. This means that Stackers do not lose money from forks, nor do forks pose a risk to the safety of users' BTC.
* We use the fact that PoX pays BTC to STX holders to propose a liveness recovery mechanism, whereby some BTC payouts are repurposed to fulfill withdrawal requests should the custodian fail.
* We reward Stackers for staying online to process 2-way peg operations by compensating them with BTC via PoX, regardless of the peg's operation volume. Stackers are compensated proportional to their signing power on the peg (i.e how many STX they locked) regardless of how many deposit and withdrawal transactions they process.

By leveraging these properties, sBTC offers the following advantages over the state-of-the-art:
* If a majority of Stackers are honest, then sBTC remains safe. Every BTC withdrawal is paired with an equivalent, legitimate request from a wrapped BTC holder, even if every miner is malicious. This is achieved by ensuring that all Stacking and wallet maintenance operations materialize in all Stacks forks.
* If a Byzantine fault-tolerant (BFT) majority of miners are honest, then sBTC remains live. All withdrawal requests are eventually fulfilled, even if every Stacker is malicious. This is because Stackers do not have a say in block production, and Stackers that do not fulfill withdrawals lose their PoX-driven BTC income from miners.
* Withdrawals of arbitrary amounts of BTC are fulfilled in a fixed amount of time on the happy path if both Stackers and miners operate with a BFT honest majority. If they do not, then withdrawals of arbitrary amounts of BTC are fulfilled eventually by redirecting Stackers' PoX payouts to fund withdrawal requests.

To support this, sBTC offers two modes of operation: Normal mode and Recovery mode.

In Normal mode, the sBTC asset is backed 1:1 by BTC sent to a wallet controlled by a large fraction of Stackers, as measured by the fraction of locked STX they represent. Each time BTC is sent to this wallet (a deposit operation), an equal number of sBTC are automatically minted to an address of the sender's choosing. Stackers respond to withdrawal requests by sending BTC to the requester's Bitcoin address, thereby maintaining the peg. The act of responding to withdrawal requests automatically destroys the requester's equivalent amount of sBTC on the Stacks chain.

If the Normal mode encounters a liveness failure for any reason (including loss of BTC), the system transitions to a Recovery mode until enough Stackers come back online.

In Recovery mode, a fraction of the PoX payouts are redirected to withdraw requests such that eventually, all outstanding requests will be fulfilled, even if the Stackers never come back online. While considerably slower than Normal mode, the design of Recovery mode ensures all sBTC can be redeemed so long as the Stacks blockchain and PoX are online.

Let's now dive deeper into the various components of sBTC and how they collectively accomplish these solutions presented. In-depth implementation details for both the Nakamoto release of Stacks (a necessary component of sBTC) and sBTC itself can be found in SIPs 021 and 025, respectively.

In the remainder of this paper, we highlight the high-level technical and economic mechanisms underpinning the sBTC design.

=== Deposits

The deposit process begins with users creating a Bitcoin transaction. This transaction, which sends an Unspent Transaction Output (UTXO) to a specific address, includes two distinct script paths. One with a special payload in an OP_DROP unlock script will need to be sent to the signer's pubkey, and another with a time locked refund path.

Then, a function in the .sbtc Clarity contract is called that performs the following actions. It verifies the Bitcoin transaction's inclusion in a particular block height and to ensure the integrity of the script paths in the output. It ensures that there are no hidden paths and that the internal key is not spendable. The transaction details, including the ID, amount, and commitment time, are logged in the .sbtc contract's data space as pending, marking the start of the deposit process.

Stackers, via their signer daemons, monitor the Stacks blockchain for new sBTC deposit states. Once detected, these Stackers initiate a signing round to process the deposit.

The minting of sBTC tokens is dependent on the consensus of these Stackers. If a majority agrees on the validity of the deposit transaction, they collectively authorize the deposit by minting an equivalent number of sBTC tokens, which are then allocated to the user's chosen account address. This process is facilitated through a collective signing mechanism known as the Weighted Schnorr Threshold Signature (WSTS).

Once stackers generate the authorization transaction, miners are required to include it, as agreed upon by the Stackers, in the next block. Stackers can enforce this inclusion by refusing to sign the block if the transaction is not included.

A crucial aspect for users is the need for their BTC deposit transaction to be confirmed on the Bitcoin network. Only after this confirmation are the sBTC tokens realized on the Stacks blockchain. This step is vital for ensuring that the minted sBTC remains fully backed by the user's BTC, which is used solely for withdrawals or in a Distributed Key Generation (DKG) wallet hand-off.


Withdrawals

Withdrawing is the act of redeeming sBTC for BTC. To redeem sBTC for BTC, the user first sends a Stacks transaction to the .sbtc contract to indicate how much sBTC they would like to redeem and the Bitcoin address to which the BTC will be sent.

This request is queued up in the .sbtc data space, which Stackers (through their signer daemons) observe and react to. When the transaction is confirmed, the user's requested sBTC is locked until the end of the next reward cycle -- the user cannot spend it while Stackers are considering the request.

When Stackers see the withdrawal request they execute a WSTS signing round to generate a Bitcoin transaction from the sBTC wallet's UTXO which pays out to the user's requested address. Because all deposited BTC is spendable by the current set of Stackers via an aggregate Schnorr signature, Stackers simply create the scriptSigs for the wallet UTXO to fund a fulfillment UTXO for all users that requested a successful withdrawal.

The approved withdrawal requests are aggregated into a single withdrawal BTC transaction from the wallet UTXO.

The BTC redemption transaction contains the following fields:

An OP_RETURN identifying the withdraw request in the .sbtc contract
A new UTXO that redeems all approved withdrawal request's sBTC for BTC

Once the Stackers have created the BTC redemption transaction, they send it to the Bitcoin peer, and send a Stacks transaction with a copy of the Bitcoin transaction to .sbtc, so that the transaction is also stored publicly in the .sbtc contract's data space. This is done for failure recovery: if the Bitcoin transaction does not confirm quickly, the Stackers can try again (see below). Also, the existence of the signed Bitcoin transaction in the .sbtc data space serves as proof that the Stackers handled the withdrawal request in a timely manner, even if it was not confirmed on Bitcoin as quickly as desired. When the .sbtc contract processes the copy of the BTC redemption transaction, it marks the UTXOs it consumes as "tentatively used" so that a concurrently-generated BTC redemption transaction does not also use them.

Once the BTC redemption transaction is confirmed on Bitcoin, a Stacks miner processes it as a Stacks-on-Bitcoin transaction. The act of processing this transaction is the act of calling into the .sbtc contract to mark the pending sBTC withdrawal as fulfilled. This burns the user's locked sBTC, and marks the withdrawal operation as complete. It also updates the .sbtc transaction's knowledge of the wallet's UTXO to be the transaction that was created to fulfill the withdrawals.

A withdraw operation can fail in the following ways, and has the following remediations:

The Stackers may not produce the redeem transaction. If they cannot reach quorum, but can complete a WSTS signing round, then they instead send a Stacks transaction to .sbtc which indicates that no quorum can be met. This is a vote to abstain. In this case, the user's sBTC remains locked until the end of the reward cycle, at which point a new set of Stackers will be selected, permitting them to try again.

There may not be enough free UTXOs to create a redeem transaction. If this happens, then Stackers must collectively sign a Stacks transaction that instead marks the withdrawal request. This unlocks the user's sBTC, so they can try again once the system is no longer congested.

The redeem transaction may never be confirmed. If this happens, then the Stackers use one of the aforementioned tactics to retry the transaction. They must do this in order to free up the UTXOs that this transaction consumes.

The set of Stackers expires when they hand off the sBTC wallet's BTC to a new set of Stackers. If this happens, then all pending sBTC withdrawal requests for the old set of Stackers are cancelled. Users will need to re-request a withdrawal to the new Stackers.

The Stackers may fail to run a WSTS signing round after a given time out (e.g. 10 Bitcoin blocks). If this happens, then the system freezes until enough Stackers can come online. This has penalties, which are described in the following section.

sBTC Wallet Transfer
The set of Stackers changes every stacking cycle (every two weeks). Because of this, a process needs to be created for handing off control of the locked BTC and deciding the new sBTC wallet between each set of Stackers.
As part of the Nakamoto release consensus rules, miners must include the new list of Stackers and their signing keys and write them into the PoX data space. The new set of Stackers is known immediately after a new PoX anchor block is mined.
Once the new set of Stackers is known, they have 99 Bitcoin blocks to carry out a WSTS DKG round amongst themselves and write the aggregate public key and BTC redeem script into the .sbtc contract. The former is needed by Nakamoto already for signing blocks. The latter is needed for users to correctly produce a deposit UTXO, which contains the hash of a redeem script; the redeem script determines the sBTC wallet's address.
The Stackers write the aggregate public key and BTC redeem script through an on-chain vote. The new Stackers submit their votes as zero-fee Stacks transactions, which they share with existing Stackers so they can compel miners include them in blocks (and should this fail for any reason, Stackers can also send their votes as normal Stacks transactions). Once the aggregate public key and BTC redeem script clinches at least 70% support as weighted by the new stackers' stacked STX, then the new Stackers are treated as active and ready to execute the sBTC wallet hand-off.

Freezing and Thawing
In the preceding sections, there are failure modes whereby the system can freeze. This can happen if the Stackers fail to execute a WSTS signing round or DKG, or fail to vote for a new sBTC wallet redeem script. If the system freezes, then STX unlocks do not happen, and PoX payouts do not happen either, for as long as the system is frozen. Instead, miners pay to a burn address, and the PoX system refuses to unlock STX. The only way the STX can unlock and PoX payments resume is if the system can be thawed. If the system remains frozen across two reward cycle boundaries -- i.e. the current set of Stackers remain frozen and the subsequent set remain frozen, then the Stacks blockchain halts.
To thaw the system:
On deposit, the system can freeze if Stackers cannot complete a WSTS signing round to vote to accept, reject, or abstain from a deposit request, and the deposit requests remain pending for too long. To thaw the system, the Stackers would need to come back online and acknowledge all pending deposit transactions. If the system remains frozen across a prepare phase, then the system can be thawed by the Stackers passing the BTC to the new set of Stackers, which would cancel the pending deposit requests.
On withdrawal, the system can freeze if Stackers cannot complete a timely signing round to vote to process the withdrawal. To thaw the system, Stackers would need to come back online to either fulfill all pending withdrawal requests, or NACK them. If the system remains frozen across a reward cycle boundary, then it thaws if the old Stackers are able to transfer their BTC to the new Stackers. This act will cancel all pending sBTC withdrawal requests.
On BTC-transfer, the system can freeze in one of two ways: the new Stackers cannot vote on a new aggregate public key and redeem script before the end of the reward cycle, or the old Stackers cannot hand off all of the BTC to the new Stackers by the start of the new reward cycle. The only way to thaw the system is for the new Stackers to eventually complete their vote and the old Stackers send over the BTC before the next PoX anchor block is mined. If the system remains frozen this way, and the next PoX anchor block is mined, then the Stacks blockchain halts.
In the event that the BTC gets "stuck" and Stackers are unable to access it, the system will support a variation of a deposit transaction called a donation. The only difference between a deposit and a donation is that the donation does not materialize sBTC. It merely gives Stackers some BTC with which to fulfill withdrawals. This feature is meant to enable Stackers to recover lost BTC and unfreeze the system, should the need ever arise.

Security Model and Capital Limits

sBTC is not BTC on Bitcoin L1. sBTC, by definition, is a pegged asset minted against locked BTC in a 1:1 manner on a Bitcoin layer (Stacks). BTC stored on the Bitcoin L1 is the most secure way to store BTC for users in general. Moving BTC to any Bitcoin layer comes with additional complexity and security assumptions; this is true for Lightning, Stacks, RSK, Liquid, and others. Lightning arguably introduces the least additional attack surface and assumptions compared to other Bitcoin layers. For sBTC on the Stacks layer, it’s important to understand the security assumptions and potential risks.
A super majority of Stackers (71%) can steal BTC from the Bitcoin script/wallet on the Bitcoin L1. Stackers will forfeit their STX capital and BTC rewards if they do this, and it might be economically irrational (given they lock more capital than the value of sBTC supply) but it is theoretically possible. The more decentralized the set of Stackers, the harder is this type of attack to pull off; other than economic incentives, it’s logistically challenging to convince hundreds or thousands of independent entities and people to coordinate and collude with each other to attempt such an attack.
This leads into another interesting and nuanced problem area that needs to be addressed by the sBTC system. One idea that was explored during the design process of sBTC was the concept of a liveness ratio, essentially a cap on the amount of sBTC that can be minted based on the value of locked STX. The cap discussion resulted from a security model of economic and reputational incentives, in which stackers have full signing control over a Bitcoin wallet containing the locked BTC. For example, for a liveness ratio of 200%, would mean that if there were $200M TVL of locked STX, the sBTC maximum capacity would be $100M BTC.
The original intent of this concept was to maintain economic incentives for the system such that there would never be enough BTC locked in the system that it would become economically strategic for 71% of the Stackers to collude to steal the BTC funds rather than process withdrawal transactions
However, a cap immediately puts a ceiling on potential DeFi usage and discourages large players from entering the system. Given these market realities, an uncapped version with trust-assumption of institutional signers as final backstop has emerged as the chosen path forward.
The STX asset primarily serves two functions: as mining incentives to maintain an open and decentralized mining system, and as the capital locked up in consensus to secure sBTC minting. With the launch of sBTC, a threshold of over 70% of signers will be required to approve deposits/withdrawals. This ensures that if at least 30% of the signers remain honest, the deposited BTC remains secure. Malicious actors would need to collude across all signers to form a consensus representing at least 70% of the total stacked capital to attempt a theft of the deposited BTC.
Our approach is that the involvement of high-reputation signers (such as large, professional entities) provides an additional layer of safety, complementing the inherent economic incentives of the system.
sBTC uses a hybrid model incorporating both anonymous signers with locked STX and known, institutional signers who carry significant weight (>30%). This approach is considered more secure than one relying solely on anonymous signers.
Traditional models, like Liquid and RSK, typically involve blind trust in a pre-set, small group of parties in a multisig setup. In contrast, the model introduced for sBTC offers several key advantages: (a) there is actual capital at stake, providing economic incentives for honesty; (b) the set of signers is dynamic and open, allowing for changes over time as opposed to a closed and static group; (c) the system can support a large number of signers, potentially over 100, unlike current multisigs limited to fewer than 10 parties.
These factors combine to create what can be considered the highest quality signer network available today. This network is not only dynamic, allowing new participants to join and increase decentralization over time, but it also includes institutional players like large custodians or exchanges. The involvement of such entities, particularly if they represent more than 30% of the signers, significantly reduces the likelihood of malicious actions due to the legal and reputational consequences.
The sBTC system, therefore, stands out as a superior alternative to single custodian models like Bitgo/WBTC or closed federations like Liquid. The combination of economic incentives (skin in the game) and reputable institutional signers provides a robust security model. It's important to note that these institutional signers, akin to exchanges and custodians, already handle large sums of BTC and are subject to similar risks of claiming hacks. Hence, the sBTC model offers a more secure, decentralized, and dynamic framework compared to existing solutions.
It is also important to keep in mind that the system and security model can and will improve over time by having more signers joining the network and leveraging technological innovations like those present in BitVM. More on this in the “Progressive enhancement” section.
In addition to the above security model and trust assumptions, there are some other potential attack vectors to be aware of.
Bitcoin L1 miners can censor stacking operations in a long-range 51% attack and attempt  to steal the BTC from the Bitcoin script/wallet. This potential attack is economically extremely hard to pull off, given (a) it requires Bitcoin miners to 51% attack the Bitcoin L1 chain for months (potentially 6+ months) and (b) purchase a large percent of STX liquid supply (at least 14%, worth approx $50M in Dec 2022). The Bitcoin L1 has never been successfully 51% attacked for even days, let alone months, making this attack largely theoretical. Further, every Bitcoin layer assumes that Bitcoin L1 miners will not be able to censor them over a long time period.
sBTC contract is written in Clarity language and is part of the Stacks consensus. Clarity is a decidable language, meaning that all contract execution paths can be known before executing the contract and rigorous security analysis can be performed. Clarity is, however, more expressive than Bitcoin script and the sBTC contract code is relatively more complex than Bitcoin script contracts typically used with BTC on L1.

Recovery Mode

Recovery mode is a future addition to sBTC (to be implemented after the initial SIP and hard fork are implemented) whereby instead of burning BTC while the system is frozen, the BTC is instead repurposed to directly fulfill pending withdrawal requests. While withdrawal fulfillment will be considerably slower, at least the sBTC users will eventually be made whole in the event of a catastrophe.

In Recovery mode, sBTC deposits would cease and all pending sBTC deposits would be canceled. Withdraws would be fulfilled in first-in first-out order from redirected PoX payouts. Once a withdrawal request has been satisfied -- i.e. the requester's BTC address has received at least as many satoshis as requested from the redirected PoX payouts -- then the withdrawal request completes and the next requester's withdrawal is processed.

Once the Stacks blockchain supports Recovery mode, the system would continue operating even if the system was frozen for many reward cycles. The blockchain would not halt; instead, it would continue its operation to fulfill all withdrawal requests while the BTC is seemingly inaccessible to Stackers. PoX payouts and STX unlocks would only resume once the current set of Stackers control enough BTC to back each sBTC token, and are able to fulfill pending sBTC withdraws.

The system would transition back to Normal mode once all pending withdrawal transactions have been fulfilled, and once the current set of Stackers possess enough BTC to cover all outstanding sBTC tokens.


Decentralized vs. Federated Bitcoin Derivatives
For Bitcoin peg systems, a decentralized approach like sBTC is not possible without an additional asset like STX that is locked in consensus. sBTC has an open membership set of signatories which is more decentralized and has economic security i.e., the economically rational path for signatories is to always maintain the peg liveness. On the other hand, for federated pegs (like Liquid) users put trust in a federation and these federation members don’t have economic risk for misbehaving, they only have reputational risk. We strongly believe that the decentralized sBTC approach is superior.

The comparison between sBTC and federated pegs highlights the need for economic incentives and the STX token. Other than being used as an incentive for securing and maintaining the Stacks layer ledger, the STX asset is critical in enabling the decentralized Bitcoin peg. Without an additional asset like STX, you can only have federated or custodial designs. In the Bitcoin community there is some resistance to new assets other than Bitcoin, which is understandable given the noisy and risky market for non-Bitcoin crypto assets. Our design allows application developers to build and use federated pegs if they wish, but the core consensus protocol focuses only on the decentralized peg. The decentralized peg is possible only because of the separate STX asset. We believe that decentralized and trustless systems are far superior in the long-term over federated designs, especially as the network passes through the initial bootstrapping stage and the sBTC circulating supply can be in billions to tens of billions of dollars providing ample liquidity to users.

Although the STX asset is necessary to serve as an economic incentive to maintain the security and permissionless nature of the network, in order for Stacks to truly be considered a Bitcoin L2, that means users should be able to take advantage of the increased functionality of smart contracts on the Stacks L2 without necessarily needing to hold any STX to pay for transaction fees.

sBTC also unlocks the possibility of using BTC as a gas fee in Stacks smart contracts, meaning users will never have to hold or interact with STX at all unless they choose to. While not part of the sBTC implementation itself, work is already underway to bring about this functionality.

Progressive Enhancement of sBTC

Progressive enhancement is a concept in software development that emphasizes creating a usable version of a product while adding enhancements over time. When building out new protocols in a constantly-evolving landscape and a new industry, it is important to keep this concept in mind.

Specifically, with sBTC, our goal is to build a practical system that is possible today, which has significant benefits beyond the current state of the art. It is to get sBTC live and then we can then collectively and iteratively improve on it over time.

With that in mind, we’ve covered the current design details of sBTC, but looking forward, what are some of the ways the system can improve over time, leveraging current and yet-to-be-known work so that we can benefit from the Lindy effect, where the longer sBTC exists, the more secure, robust, and usable it becomes?

Many of the design decisions being made for sBTC are being made with this forward-looking context. One of the key differentiators between sBTC and other systems is its permissionless nature. We discussed the hybrid security model above, finding the balance between relying on economic incentives, supply cap, and reputational trust models.

One major benefit to permissionless systems is that anybody is free to join. As more and more signers join the network, the economic security of the system will only grow. This means that as the Stacks network itself and the amount of BTC represented as sBTC grow, the security model of the system improves as well. This is different from other systems where the security model remains stagnant even as the capital locked in the system increases.

In addition to a gradually improving security model as the network and economic security increases, sBTC is well-positioned to take advantage of future technological innovations in the Bitcoin ecosystem, including things like new op-codes related to rollup validation or reducing trust assumptions to a single honest verifier with something like BitVM. These are new and promising (although still theoretical) avenues for potential future enhancements to sBTC.

By building and deploying a working version of sBTC now, we can create a system that has acceptable security and trust assumptions while simultaneously working on ecosystem growth and iteratively shipping enhancements and improvements as technological innovations enable the community to do so.


Related Work
Sidechains [2] proposed the idea of pegging Bitcoin into a Bitcoin layer. As of 2023, sidechain implementations in the Bitcoin ecosystem, like Liquid or RSK [5], don’t implement open- membership Bitcoin peg-outs. They rely on a federation of known, trusted entities or centralized custodians to do this (although RSK is currently working on moving to a decentralized model called Powpeg, with). Nomic [11] has implemented a decentralized Bitcoin bridge/peg in the Cosmos ecosystem which is at an early stage. Projects like tBTC [12] and renBTC have implemented decentralized approaches to Bitcoin-pegged assets for Ethereum (recently renBTC is moving to a federated design). tBTC has an open-membership signer set with economic security (similar to sBTC) and most of the differences between sBTC and tBTC stem from the tight integration of the Stacks layer with Bitcoin L1: Stacks has Bitcoin read support (so no need to rely on Bitcoin SPV), Stacks Nakamoto release transactions follow Bitcoin finality, and withdrawal requests happen on Bitcoin L1 (vs relying on an external system like Ethereum). tBTC is intended for a different use, where it brings a BTC-pegged asset to the already established application economy of Ethereum. sBTC is intended to grow a Bitcoin application economy as natively around Bitcoin L1 as possible.

Drivechain [6] (BIP-300) proposed a two-way Bitcoin peg in 2015. Drivechain, unlike sBTC on Stacks, requires modifications to Bitcoin L1. Further, users can peg-out their assets with a delay of 3 months (vs. 150 blocks or approx a day in sBTC) and there are no coinbase rewards as incentives for miners. Drivechain is still at a proposal stage as a Bitcoin Improvement Proposal (BIP), even after several years. Given the requirement to modify Bitcoin L1, and slow peg-out, the proposal may not be commercially viable. sBTC has stronger economic security than drivechain against potential 51\% attacks from Bitcoin L1 miners, given Bitcoin L1 miners will need to (a) attempt a 51% attack for longer time periods and (b) purchase a large portion of


STX liquid supply up front. Spacechains [13] is another proposal, at a proof of concept stage, that proposes a one-way peg. Similar to drivechain, it does not require an alternate token but lacks incentives for miners to participate in the system (no coinbase rewards). Further, a one- way peg is not sufficient for many applications, like BTC lending, decentralized exchanges etc, where users want to bring BTC back to the Bitcoin L1 after use.

Conclusion
Unlocking hundreds of billions of dollars in Bitcoin capital is a major untapped opportunity. Bitcoin layers can enable DeFi and other applications for BTC but have a major limitation: there is currently no way for users to move their BTC in and out of smart contracts running on Bitcoin layers in a fully decentralized manner. This is called the Bitcoin peg-out problem and has been a "holy grail" problem in Bitcoin for almost a decade; so far we’ve only seen federated/centralized approaches.

In this paper, we present a decentralized two-way Bitcoin peg system. Unlike earlier approaches where a fixed federation or federation of multisig wallets needs to be trusted by users, this new approach has economic security through an open-membership and dynamic set of signatories. Further, users don’t pay any fees when moving their BTC in and out of the Bitcoin layer and the dynamic set of signatories are rewarded in BTC for their work by the consensus protocol.

This work brings us closer to building ideal Bitcoin layers. Not only do users have access to full smart contracts at the layer but they can easily move their assets in and out of the layer in a decentralized manner while their transactions are secured by 100% of the base layer security. This work can unlock a new era of Bitcoin applications that can accelerate the growth of the Bitcoin economy.

[bibliography]
== References

* [[[bitcoin,1]]] Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash system. Tech report, 2009.
https://bitcoin.org/bitcoin.pdf
* [[[sidechains,2]]] Adam Back, Matt Corallo, Luke Dashjr, Mark Friedenbach, Gregory Maxwell, Andrew
Miller, Andrew Poelstra, Jorge Timon, and Pieter Wuille. Enabling Blockchain Innovations with Pegged Sidechains. White paper, Blockstream, 2014. https://blockstream.com/sidechains.pdf
* [[[stacks-nakamoto,3]]] Stacks: A bitcoin layer for smart contracts, Dec 2022. https://stx.is/nakamoto
* [[[stacking-stats,4]]] Stacking stats. https://stacking.club/cycles/all
* [[[RSK,5]]] RSK whitepaper: Bitcoin Powered Smart Contracts, 2019. https://www.rsk.co/Whitepapers/RSK-White-Paper-Updated.pdf
* [[[drivechain,6]]] Drivechain (BIPs 300+301). https://www.drivechain.info/
* [[[ethereum,7]]] Vitalik Buterin. A next-generation smart contract and decentralized application platform. Technical report, 2014. https://ethereum.org/en/whitepaper/.
* [[[sbtc-sip,8]]] SIP 021: Trustless Two-way Peg to Bitcoin. https://github.com/stacksgov/sips/pull/113.
* [[[magic-swaps,9]]] Magic protocol for atomic swaps with BTC and Stacks. https://magicstx.gitbook.
io/magic-protocol/overview/magic-protocol.
* [[[defi-swaps,10]]] Muneeb Ali. Bitcoin DeFi is here: A deep dive into trust-less swaps, 2021. https://www.
hiro.so/blog/bitcoin-defi-is-here-a-deep-dive-into-trust-less-swaps.
* [[[nomic,11]]] Nomic: A Non-Custodial Proof of Stake Bitcoin Sidechain on Cosmos. https://nomic.
io/.
* [[[tbtc,12]]] tBTC: A Decentralized Redeemable BTC-backed ERC-20 Token. https://docs.keep.
network/tbtc/index.pdf.
* [[[spacechains,13]]] Spacechains proof of concept. https://github.com/RubenSomsen/spacechains.